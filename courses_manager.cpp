#include "courses_manager.h"#include "exceptions.h"#include <memory>using std::shared_ptr;#define COURSE_NOT_FOUND -1CoursesManager::CoursesManager() : course_hash_table(HashTable<Course>()), time_order_tree(AVL_Tree<Time>())  { }void CoursesManager::addCourse(int courseID){    Course course_to_add(courseID);    Course found = course_hash_table[courseID];    if (found.getCourseID() != COURSE_NOT_FOUND){        throw Failure();    }    course_hash_table.insert(course_to_add);}void CoursesManager::removeCourse(int courseID){    // find the course in the hash table    Course course_to_remove = course_hash_table[courseID];    if (course_to_remove.getCourseID() == COURSE_NOT_FOUND){        throw Failure();    }    // removeAllClasses goes through each of the classes in the array and removes it from time_order_tree    course_to_remove.removeAllClasses(time_order_tree, course_hash_table);    course_hash_table.remove(course_to_remove);}    int CoursesManager::addClass(int courseID){    Course found = course_hash_table[courseID];    if (found.getCourseID() == COURSE_NOT_FOUND){        throw Failure();    }    int res = found.addClass();    // std::cout << course_hash_table[courseID];    course_hash_table[courseID] = found;    return res;}void CoursesManager::watchClass(int courseID, int classID, int time) {       //access the courseID in course_tree.    //print(2);    // Course course_found = course_hash_table[courseID];    if (course_hash_table[courseID].getCourseID() == COURSE_NOT_FOUND){        throw Failure();    }    if (classID+1 > course_hash_table[courseID].getNumOfClasses()){        throw InvalidInput();    }    //in the current course: 1. update class.timeviewed    course_hash_table[courseID][classID].setTime(time);    // remove from time_order_tree the node class.time_order_tree_ptr was pointing on.    if(course_hash_table[courseID][classID].getTimeOrderTreePtr() != NULL){        if (course_hash_table[courseID][classID].getTimeOrderTreePtr()->getNumOfChildren() == 2){            shared_ptr<Node<Time>> next_smallest_time = time_order_tree.findSmallestNode(course_hash_table[courseID][classID].getTimeOrderTreePtr()->getRightChild()); //CHANGED            int next_course_id = next_smallest_time->getData().getCourseID();            int next_class_id = next_smallest_time->getData().getClassID();            course_hash_table[next_course_id][next_class_id].setTimeOrderTreePtr(course_hash_table[courseID][classID].getTimeOrderTreePtr());        }        time_order_tree.removeNode((course_hash_table[courseID][classID].getTimeOrderTreePtr())->getData());    }    // create Time new_time(courseID, classID, time)    shared_ptr<Time> new_time(new Time(courseID, classID, course_hash_table[courseID][classID].getTime()));    shared_ptr<Node<Time>> time_to_add_ptr(new Node<Time>(*new_time, 0, 1));    // add it to time_order_tree    time_order_tree.addNode(time_to_add_ptr);    // update class.time_order_tree_ptr to point on find(new_time)    course_hash_table[courseID][classID].setTimeOrderTreePtr(time_order_tree.find(*new_time, time_order_tree.getRoot()));    // course_hash_table[courseID] = course_found;    // print(2);}int CoursesManager::timeViewed(int courseID, int classID) {    Course course_to_find = course_hash_table[courseID];    if (course_to_find.getCourseID() == COURSE_NOT_FOUND){        throw Failure();    }    if (classID+1 > course_to_find.getNumOfClasses()){        throw InvalidInput();    }    return course_to_find[classID].getTime();}void CoursesManager::GetIthWatchedClass(int i, int* courseID, int* classID) {    shared_ptr<Node<Time>> node_i = time_order_tree.select(i, time_order_tree.getRoot());    if (!node_i)        throw Failure();    courseID[0] = node_i->getData().getCourseIDRefrence();    classID[0] = node_i->getData().getClassIDRefrence();}void CoursesManager::print(int num) {    if(num == 2) {        time_order_tree.printTree(0);    }    else if(num == 1) {        course_hash_table.printHash();    }}void CoursesManager::printTimeForCourse(int courseID) {    Course course_to_find = course_hash_table[courseID];    course_to_find.printTimeForClass();}